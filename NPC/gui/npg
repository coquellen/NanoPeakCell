#!/usr/bin/env python
from PyQt4 import QtGui, QtCore
import pyqtgraph as pg
import os
from Views import ImageView, XPView, TreeFileView, HitFindingView, TableWidget
from Models import NPGData
import inspect
from Stream import CrystFELStream as CStream
from NPC import utils
import json
from NPC.PreProcessing import DataProcessingMultiprocessing as DataProc
from PyQt4.QtCore import pyqtSignal
import shutil
import glob
app = QtGui.QApplication([])
from ZmqSockets import NPGPull

class NPCThread(QtCore.QThread):

    stop = pyqtSignal()

    def __init__(self, params):
        QtCore.QThread.__init__(self, )
        self.Process = DataProc(params)

    def run(self, priority=None):
        self.Process.run()
        self.stop.emit()

class NPGMenuBar(QtGui.QMenuBar):
    def __init__(self):
        QtGui.QMenuBar.__init__(self)

        self.menuFile = self.addMenu("&File")
        self.actionLoad_Images = self.menuFile.addAction("&Load Images")
        self.actionLoad_Images.setShortcut('Ctrl+O')
        self.actionLoad_Mask = self.menuFile.addAction("&Load Mask")
        self.actionLoad_Mask.setShortcut('Ctrl+M')
        self.actionLoad_Geometry = self.menuFile.addAction("&Load Geometry")
        self.actionLoad_Geometry.setShortcut('Ctrl+G')
        self.actionSep1 = self.menuFile.addAction("")
        self.actionSep1.setSeparator(True)

        self.action_Clear = self.menuFile.addAction("&Clear Image List")
        self.action_Clear.setShortcut('Ctrl+C')
        self.actionDelete_Mask = self.menuFile.addAction("&Delete Mask")
        self.actionDelete_Geom = self.menuFile.addAction("&Delete Geom")
        self.actionSep2 = self.menuFile.addAction("")
        self.actionSep2.setSeparator(True)
        self.actionClose = self.menuFile.addAction("&Close")



        self.menuShow = self.addMenu("&Show")
        self.actionBeam_Center = QtGui.QAction("&Beam Center", self)
        self.actionBeam_Center.setShortcut('Ctrl+B')
        self.actionBeam_Center.setCheckable(True)
        self.actionBeam_Center.setChecked(False)
        self.actionBeam_Center.setIconVisibleInMenu(False)
        self.actionResolution_Rings = QtGui.QAction("&Resolution Rings", self)
        self.actionResolution_Rings.setShortcut('Ctrl+R')
        self.actionResolution_Rings.setCheckable(True)
        self.actionResolution_Rings.setChecked(True)
        self.actionBragg_Peaks = QtGui.QAction("&Bragg Peaks", self)
        self.actionBragg_Peaks.setShortcut('Ctrl+P')
        self.actionResolution_Rings.setCheckable(True)
        self.actionResolution_Rings.setChecked(False)
        self.menuShow.addAction(self.actionBeam_Center)
        self.menuShow.addAction(self.actionResolution_Rings)


        self.menuView = self.addMenu("&View")
        self.actionFile_Tree = QtGui.QAction("&Image List", self)
        self.actionFile_Tree.setCheckable(True)
        self.actionFile_Tree.setChecked(True)
        self.actionExperimental_Settings = QtGui.QAction("&Experimental Settings", self)
        self.actionExperimental_Settings.setCheckable(True)
        self.actionExperimental_Settings.setChecked(True)
        self.actionHit_Finding = QtGui.QAction("&Hit Finding", self)
        self.actionHit_Finding.setCheckable(True)
        self.actionHit_Finding.setDisabled(True)
        self.actionRuns = QtGui.QAction("&NPC Runs", self)
        self.actionRuns.setCheckable(True)
        self.actionRuns.setDisabled(True)

        self.menuView.addAction(self.actionFile_Tree)
        self.menuView.addAction(self.actionExperimental_Settings)
        self.menuView.addAction(self.actionHit_Finding)
        self.menuView.addAction(self.actionRuns)

        self.menuMode = self.addMenu("&NPG Mode")
        #self.MenuModeOff = self.menuMode.addMenu("&Offline")
        self.actionOffImages = self.menuMode.addAction("&Display Images")
        self.actionOffImages.setCheckable(True)

        self.actionStream = self.menuMode.addAction("&Inspect Stream")
        self.actionStream.setCheckable(True)
        #self.actionStream.setEnabled(False)

        #self.MenuModeOn = self.menuMode.addMenu("&Online")
        #self.actionOnPort = self.MenuModeOn.addAction("&Listen a port")
        #self.actionOnPort.setCheckable(True)
        #self.actionOnEiger = self.MenuModeOn.addAction("&Listen Eiger Stream")
        #self.actionOnEiger.setCheckable(True)
        #self.actionOnEiger.setEnabled(False)

        self.OffGroup = QtGui.QActionGroup(self.menuMode)
        self.OffGroup.addAction(self.actionOffImages)
        self.OffGroup.addAction(self.actionStream)
        #self.OffGroup.addAction(self.actionOnPort)
        #self.OffGroup.addAction(self.actionOnEiger)
        self.actionOffImages.setChecked(True)

    #Slots for emitted signals
    def UncheckMenuView(self,attr):
        Qaction = getattr(self,str(attr))
        Qaction.setChecked(False)

class NPGController(object):

    def __init__(self, app):
        self.app = app
        self.binning = 1
        self.settings = QtCore.QSettings('Mycompany', 'NPG')
        self.XPView = XPView(False)
        self.ImageView = ImageView(self.XPView, None, self.binning, req= "HIT", timeout= 100, name='ImageView')
        self.TreeFileView = TreeFileView()
        self.HitFindingView = HitFindingView(self)
        self.Table = TableWidget()
        self.ImgModel = NPGData()
        self.menuBar = NPGMenuBar()
        self.menuBar.setGeometry(QtCore.QRect(0, 0, 1060, 27))
        self.ImageView.setMenuBar(self.menuBar)
        self.menuBar.setNativeMenuBar(False)


        self.NPGPuller = NPGPull('127.0.0.1', 5556, self.ImgModel, self.Table, opts=[], flags=None)

        self.currentMode = "OffImage"
        self.cwd = os.getcwd()

        # The dealing of NPC jobs should be done in a different object
        self.nRun = 1
        self.waitingList = []
        self.waitingDic = {}
        self.running = []
        #
        self.menuBar.show()
        self.restoreState()

        self.restoreRuns()

        # Bindings with emitted signals
        self.ImageView.closeSignal.connect(self.CloseAll)
        self.TreeFileView.hideMe.connect(self.menuBar.UncheckMenuView)
        self.XPView.hideMe.connect(self.menuBar.UncheckMenuView)
        self.HitFindingView.hideMe.connect(self.menuBar.UncheckMenuView)
        self.Table.hideMe.connect(self.menuBar.UncheckMenuView)

        self.TreeFileView.openFile.connect(self.ImgModel.updateData)
        self.Table.loadResults.connect(self.LoadResults)
        self.Table.deleteFolder.connect(self.deleteFolder)
        self.Table.stop.connect(self.stopNPCviaTable)


        # Binding with Table

        #Binding wit FileTree
        self.TreeFileView.ui.LoadResultsBut.clicked.connect(self.loadImages)
        self.TreeFileView.ui.PlayButton.clicked.connect(self.TreeFileView.play)
        self.TreeFileView.ui.StopButton.clicked.connect(self.TreeFileView.stop)

        #Binding with ImgModel
        self.ImgModel.updateImageView.connect(self.ImageView.setImg)
        self.ImageView.ui.radioButton1.toggled.connect(self.onToggled)
        self.ImageView.ui.radioButton2.toggled.connect(self.onToggled)

        # Bindings with HF
        self.HitFindingView.ui.PlayButton_2.clicked.connect(self.startNPC)
        self.HitFindingView.ui.Stop.clicked.connect(self.stopNPC)
        self.HitFindingView.ui.MaskPathBut.clicked.connect(lambda: self.openMask(openfn=True))
        self.HitFindingView.ui.MaskDelBut.clicked.connect(self.deleteMask)
        self.HitFindingView.setTable.connect(self.restoreRuns)


        #Bindings with Menu
        self.menuBar.actionLoad_Images.triggered.connect(self.loadImages)
        self.menuBar.actionLoad_Mask.triggered.connect(lambda: self.openMask(openfn=True))
        self.menuBar.actionLoad_Geometry.triggered.connect(lambda: self.openGeometry(openfn=True))
        self.menuBar.action_Clear.triggered.connect(self.TreeFileView.clearTree)
        self.menuBar.actionDelete_Mask.triggered.connect(self.deleteMask)
        self.menuBar.actionDelete_Geom.triggered.connect(self.deleteGeom)
        self.menuBar.actionClose.triggered.connect(self.CloseAll)

        self.menuBar.actionResolution_Rings.triggered.connect(self.toggleResRings)
        self.menuBar.actionBeam_Center.triggered.connect(lambda: self.toggleBeamCenter(self.ImageView.view.beam))

        self.ViewMenuDict = { 'XP' : ('actionExperimental_Settings', self.XPView),
                              'TreeFile': ('actionFile_Tree', self.TreeFileView),
                              'HF' : ('actionHit_Finding', self.HitFindingView),
                               'Runs' : ('actionRuns', self.Table)}
        self.menuBar.actionExperimental_Settings.triggered.connect(lambda: self.toggleView('XP'))
        self.menuBar.actionFile_Tree.triggered.connect(lambda: self.toggleView('TreeFile'))
        self.menuBar.actionHit_Finding.triggered.connect(lambda: self.toggleView('HF'))
        self.menuBar.actionRuns.triggered.connect(lambda: self.toggleView('Runs'))

        QActionModes = [self.menuBar.actionOffImages,
                        self.menuBar.actionStream]
                        #self.menuBar.actionOnPort,
                        #self.menuBar.actionOnEiger]

        self.MenuModes = {'&Inspect Stream': 'OffStream',
                          '&Display Images': 'OffImage',
                          '&Listen a port': 'OnPort'}

        #self.HitLiveView.raiseAll.connect(self.raiseAll)
        self.XPView.raiseAll.connect(self.raiseAll)
        self.ImageView.raiseAll.connect(self.raiseAll)
        self.TreeFileView.raiseAll.connect(self.raiseAll)
        self.Table.raiseAll.connect(self.raiseAll)
        self.HitFindingView.raiseAll.connect(self.raiseAll)
        self.views = [self.ImageView, self.XPView, self.Table, self.HitFindingView, self.TreeFileView]

        for cnt, item in enumerate(QActionModes):
            item.triggered.connect(self.switchingMode)

    def raiseAll(self, s):
        for view in self.views:
            view.raise_()
        view_clicked = getattr(self, str(s))
        view_clicked.raise_()


    def toggleView(self, key):
        attr, view = self.ViewMenuDict[key]
        if getattr(self.menuBar, attr).isChecked():
            view.show()
            view.visible = True
        else:
            view.hide()

    def toggleBeamCenter(self, beam):
            if beam.isVisible():
                beam.hide()
            else:
                if hasattr(self.ImgModel.data, 'shape'):
                    beam.setPos(self.XPView.bx, self.XPView.by, self.binning)
                    beam.show()
                else:
                    print("No data loaded")
                    self.menuBar.actionBeam_Center.setChecked(False)

    def toggleResRings(self):
        if self.ImageView.setResRingsPosition():
            if self.ImageView.view.rings[0].isVisible():
                for r in self.ImageView.view.rings: r.hide()
                for txt in self.ImageView.view.ringsTxt: txt.hide()
            else:
                for r in self.ImageView.view.rings: r.show()
                for txt in self.ImageView.view.ringsTxt: txt.show()
        else:
            self.menuBar.actionResolution_Rings.setChecked(False)

    def startNPC(self):
        NPC_parameters = {
             'detector': 'Eiger4M',
             'experiment': 'SSX',
             'detector_distance': 100,
             'beam_x': 502,
             'beam_y': 515,
             'wavelength': 0.832,
             'num': str(int(self.nRun)+1),
             'HitFile': None,
             'live': False,
        }
        extraARGS = self.HitFindingView.getAllParameters()
        NPC_parameters.update(extraARGS)
        self.nRun += 1
        NPC_parameters['num'] = str(self.nRun)
        results = os.path.join(NPC_parameters['output_directory'], 'NPC_run%s' % NPC_parameters['num'].zfill(3))
        NPC_parameters['json_file'] = os.path.join(results, '.NPC_params.json')
        NPC_parameters['currentRow'] = self.Table.currentRow

        self.Table.addRow(self.nRun, Done=False)

        if not self.running:
            self.runNPC(NPC_parameters)
            self.running.append(NPC_parameters)
        else:
            self.waitingDic[str(self.nRun)] = NPC_parameters
            self.waitingList.append(str(self.nRun))
        #shutil.copyfile(config_file, os.path.join(options['output_directory'], 'NPC_run%s' % options['num'].zfill(3),
        #                                          os.path.basename(config_file)))

    def runNPC(self, params):
        utils.create_results_folders(params)
        self.nRow = params['currentRow']
        self.ImgModel.IO.shutDown()
        self.NPCRun = NPCThread(params)
        self.Table.setActiveRow(self.nRow)
        self.Table.stopButton.setEnabled(True)
        self.NPCRun.stop.connect(self.stopNPC)
        self.Table.Delete.setDisabled(True)
        self.NPCRun.start()
        self.NPGPuller.start()

    def stopNPCviaTable(self, row):
        print(row, self.nRow)
        if row == self.nRow:
            self.stopNPC(fromThread=False)

    def stopNPC(self, fromThread=True):
            import time
            if not fromThread:
                self.NPCRun.stop.disconnect(self.stopNPC)
                for worker in self.NPCRun.Process.consumers:
                    worker.shutDown()
                    worker.join()
                self.NPCRun.Process.shutDown()

            self.Table.stopButton.setDisabled(True)
            self.Table.Delete.setEnabled(True)
            self.ImgModel.IO.shutDown()
            self.NPGPuller.stop()
            self.NPCRun.quit()


            #self.disconnectOnPort()
            self.Table.Results.setEnabled(True)
            if self.waitingList:
                key = self.waitingList[0]
                self.running.append(key)
                self.waitingList.pop(0)
                params = self.waitingDic[key]
                del self.waitingDic[key]
                self.runNPC(params)
            if self.running:
                self.running.pop(0)

    def deleteFolder(self, run):
        path = os.path.expanduser(
            str(self.HitFindingView.ui.ResultsPath.text()))  # "~toto" -> "/home/toto" "C:\User\toto"
        path = os.path.expandvars(path)  # "/xxx/$MACHIN/yyy" -> "/xxx/valeur_machin/yyy"
        path = os.path.realpath(path)  # "/x/y/../z" -> "/x/z"
        key = str(run).lstrip("0")
        if int(run) == self.nRun: self.nRun -= 1
        if key in self.waitingDic.keys():
            print("Deleting key: %s"%key)
            del self.waitingDic[key]
            self.waitingList.remove(key)
            for run in self.waitingList:
                if run > key:
                    self.waitingDic[run]['currentRow'] -= 1

        else:
            self.nRow -= 1
            self.Table.setActiveRow(self.nRow)
            for run in self.waitingList:
                self.waitingDic[run]['currentRow'] -= 1

        try:
            shutil.rmtree(os.path.join(path, 'NPC_run%s' % run))
        except OSError:
            pass

    def LoadResults(self, run):
        path = os.path.expanduser(str(self.HitFindingView.ui.ResultsPath.text()))  # "~toto" -> "/home/toto" "C:\User\toto"
        path = os.path.expandvars(path)  # "/xxx/$MACHIN/yyy" -> "/xxx/valeur_machin/yyy"
        path = os.path.realpath(path)  # "/x/y/../z" -> "/x/z"
        try:
            json_file = os.path.join(path, 'NPC_run%s' % run, '.NPC_params.json')
            options = json.loads(open(json_file).read())
            root = options['filename_root']
            txt = os.path.join(path, 'NPC_run%s' % run, '%s_%s.txt' % (root, run))
            self.TreeFileView.treeFactory.append_file(txt)#run_hits(txt)
            self.TreeFileView.setVisible(True)
        except IOError:
            print("Sorry, cannot load Results from ...")

    def loadImages(self):
        if self.TreeFileView.isHidden():
            self.menuBar.actionFile_Tree.trigger()
        path = QtGui.QFileDialog.getExistingDirectory(
                       None,
                       "Select a folder",
                       self.cwd,
            QtGui.QFileDialog.DontUseNativeDialog | QtGui.QFileDialog.ShowDirsOnly)
        if path:
            self.cwd=path
            self.TreeFileView.clearTree()
            self.TreeFileView.treeFactory.run(str(path))

    def loadStream(self):
        self.streamFile = str(self.getFile())
        if self.streamFile:
            self.cwd = os.path.split(self.streamFile)[0]
            os.chdir(self.cwd)
            self.parseStream(self.streamFile)

    def parseStream(self, streamfn):
        mainThread = QtCore.QThread.currentThread()
        self.stream = CStream(streamfn, mainThread)
        self.stream.update.connect(self.TreeFileView.testing)
        self.stream.info.connect(self.infoStream)
        self.stream.sendGEOM.connect(self.ImgModel.updateStreamGeom)
        self.ImageView.ui.Geom.setText("Current Geometry File from stream:  %s" % streamfn)
        self.objThread = QtCore.QThread()
        self.stream.moveToThread(self.objThread)
        self.stream.finished.connect(self.parsedStream)
        self.objThread.started.connect(self.stream.parse_stream)
        self.ImageView.ui.radioButton1.setDisabled(True)
        self.ImageView.ui.radioButton2.setDisabled(True)
        self.TreeFileView.ui.LoadResultsBut.setDisabled(True)
        self.objThread.start()

    def parsedStream(self):
        self.objThread.quit()
        self.ImageView.ui.radioButton1.setDisabled(False)
        self.ImageView.ui.radioButton2.setDisabled(False)
        self.TreeFileView.ui.LoadResultsBut.setDisabled(False)
        self.ImageView.ui.Nfiles.setText("%s frames, %s crystals" % (len(self.stream.filenames), len(self.stream.indexed)))

    def infoStream(self, info):
        nimages, ncrystals = info
        self.ImageView.ui.Nfiles.setText("Parsing stream: %s frames, %s crystals" % (nimages, ncrystals))

    def onToggled(self):
        self.TreeFileView.showIndexed = self.ImageView.ui.radioButton2.isChecked()
        try:
            self.TreeFileView.testing((self.stream.filenames,self.stream.indexed), clear=True)
        except AttributeError:
            pass

    def OnIntegratedPeaks(self):
        if self.integrated is not None:
            if self.ui.InetgratedPeaks.isChecked():
                self.IntegratedPlot.setData(self.integratedPeaks[0],self.integratedPeaks[1])
                self.DetectedPlot.setBrush(self.brush1)
            else:
                self.IntegratedPlot.setData([])
                self.DetectedPlot.setBrush(self.brush0)
        if self.ui.DetectedPeaks.isChecked():
            self.DetectedPlot.clear()
            self.DetectedPlot.setData(self.detectedPeaks[0],self.detectedPeaks[1])

    def OnDetectedPeaks(self):
        if self.peaks is not None:
            if self.ui.DetectedPeaks.isChecked():
                if self.ui.InetgratedPeaks.isChecked():
                    self.DetectedPlot.setBrush(self.brush1)
                self.DetectedPlot.setData(self.detectedPeaks[0], self.detectedPeaks[1])
            else:
                self.DetectedPlot.setData([])

    def openMask(self,openfn=True):
        if openfn :
            self.maskFile = str(self.getFile())
        if self.maskFile:
            self.ImgModel.updateMask(self.maskFile)
            dim1, dim2 = self.ImgModel.mask.shape
            self.ImageView.ui.Mask.setText(
                "Current Mask File:  %s - Shape: %5i x %5i" % (self.maskFile, dim1, dim2))
            self.HitFindingView.ui.MaskPath.setText(self.maskFile)

    def openGeometry(self, openfn=True):
        if openfn:
            self.geomFile = str(self.getFile())
        if self.geomFile:
            self.ImageView.ui.Geom.setText("Current Geometry File:  %s" % self.geomFile)
            self.ImgModel.updateGeom(self.geomFile)

    def getFile(self, var=None):
        print("Called")
        d = QtGui.QFileDialog.getOpenFileName(
                None,
                "Select a File",
                self.cwd
        )
        #print d
        if var is not None:
            var.setText(d[0])
        return d

    def deleteMask(self):
        self.maskFile = ""
        self.ImgModel.loadedMask = False
        self.ImageView.ui.Mask.setText("Current Mask File:  N/A")
        self.HitFindingView.ui.MaskPath.setText("")

    def deleteGeom(self):
        self.geomFile = ""
        self.ImgModel.loadedGeom = False
        self.ImageView.ui.Geom.setText("Current Geom File:  N/A")

    def CloseAll(self, evt):
        self.saveState()
        for view in [self.XPView, self.TreeFileView, self.HitFindingView]:
            view.close()
        self.app.quit()

    def restoreState(self):
        geoms = ['geometry_XPView', 'geometry_ImageView', 'geometry_Tree', 'geometry_HF', 'geometry_Table']
        visStates = ['visible_XPView', 'visible_ImageView', 'visible_Tree', 'visible_HF', 'visible_Table']
        views = [self.XPView, self.ImageView, self.TreeFileView, self.HitFindingView, self.Table]
        menus = [self.menuBar.actionExperimental_Settings, None, self.menuBar.actionFile_Tree, self.menuBar.actionHit_Finding, self.menuBar.actionRuns]# , self.TreeFileView, self.HitFindingView]
        for i in range(len(views)):
            view = views[i]

            # Restore geomtry
            geometry = self.settings.value(geoms[i], '')

            try:
                # Python 2
                view.restoreGeometry(geometry.toByteArray())
                # Python 3
            except AttributeError: view.restoreGeometry(geometry)
            # Restore state (Visble or not)
            try:
                vis = self.settings.value(visStates[i],True).toBool()
            except AttributeError:
                vis = self.settings.value(visStates[i], True)

            view.setVisible(vis)
            view.visible = vis

            # Restore menu state
            menu = menus[i]
            if menu is not None:
                menu.setChecked(vis)

            for name, obj in inspect.getmembers(view.ui):
                if isinstance(obj, QtGui.QComboBox):
                    index = obj.currentIndex()  # get current region from combobox
                    name = obj.objectName()
                    try: value = str(self.settings.value(name).toString())
                    except AttributeError: value = str(self.settings.value(name))
                    if value == "":
                        continue

                    index = obj.findText(value)  # get the corresponding index for specified string in combobox

                    if index == -1:  # add to list if not found
                        obj.insertItems(0, [value])
                        index = obj.findText(value)
                        obj.setCurrentIndex(index)
                    else:
                        obj.setCurrentIndex(index)  # preselect a combobox value by index

                if isinstance(obj, QtGui.QLineEdit):
                    name = obj.objectName()
                    try:
                        value = self.settings.value(name).toString()  # get stored value from registry
                    except AttributeError:
                        value = self.settings.value(name)  # get stored value from registry
                    try:
                        obj.setText(value)  # restore lineEditFile
                    except TypeError:
                        continue
                if isinstance(obj, QtGui.QCheckBox):
                    name = obj.objectName()
                    try:
                        value = self.settings.value(name).toBool()  # get stored value from registry
                    except AttributeError:
                        value = self.settings.value(name)
                      # get stored value from registry
                    if value != None:
                        obj.setChecked(value)  # restore checkbox

                if isinstance(obj, QtGui.QRadioButton):
                    name = obj.objectName()
                    try:
                        value = self.settings.value(name).toBool()  # get stored value from registry
                    except AttributeError:
                        value = self.settings.value(name)

                    try:
                        if value != None:
                            obj.setCheckState(value)
                    except: pass

        # Do not forget to restore the object attributes to the widget values.
        self.ImageView.setAttr()
        self.XPView.setupData()

        #Restore Extra Settings
        try:
            self.TreeFileView.treeFactory.restoreTree(self.settings.value("Tree", {}).toPyObject())
        except:
            self.TreeFileView.treeFactory.restoreTree(self.settings.value("Tree", {}))
        try:
            self.maskFile = str(self.settings.value("Mask","").toString())

        except AttributeError:
            self.maskFile = self.settings.value("Mask", "")

        if self.maskFile:
            try:
                self.openMask(openfn=False)
            except:
                print("Error loading mask: %s" %self.maskFile)
        try:
            self.geomFile = str(self.settings.value("Geometry","").toString())
        except AttributeError:
            self.geomFile = str(self.settings.value("Geometry", ""))


        #if self.geomFile:
        #    self.openGeometry(openfn=False)

    def saveState(self):
        geoms = ['geometry_XPView', 'geometry_ImageView', 'geometry_Tree', 'geometry_HF', 'geometry_Table']
        visStates = ['visible_XPView', 'visible_ImageView', 'visible_Tree', 'visible_HF', 'visible_Table']
        views = [self.XPView, self.ImageView, self.TreeFileView, self.HitFindingView, self.Table]

        self.settings.setValue("Tree",self.TreeFileView.treeFactory.filenames_dic)
        self.settings.setValue("Mask", self.maskFile)
        self.settings.setValue("Geometry", self.geomFile)

        for i  in range(len(views)):
            view = views[i]
            geom = geoms[i]
            vis = visStates[i]
            self.settings.setValue(geom, view.saveGeometry())
            self.settings.setValue(vis, view.visible)

            for name, obj in inspect.getmembers(view.ui):
                # if type(obj) is QComboBox:  # this works similar to isinstance, but missed some field... not sure why?
                if isinstance(obj, QtGui.QComboBox):
                    name = obj.objectName()  # get combobox name
                    index = obj.currentIndex()  # get current index from combobox
                    text = obj.itemText(index)  # get the text for current index
                    self.settings.setValue(name, text)  # save combobox selection to registry

                if isinstance(obj, QtGui.QLineEdit):
                    name = obj.objectName()
                    value = obj.text()
                    self.settings.setValue(name, value)  # save ui values, so they can be restored next time

                if isinstance(obj, QtGui.QCheckBox):
                    name = obj.objectName()
                    state = obj.isChecked()
                    self.settings.setValue(name, state)

                if isinstance(obj, QtGui.QRadioButton):
                    name = obj.objectName()
                    value = obj.isChecked()  # get stored value from registry
                    self.settings.setValue(name, value)

    def switchingMode(self):
        print("Switching Off Current Mode: %s" % self.currentMode)
        s = 'disconnect' + self.currentMode
        call = getattr(self, s)
        call()

        MenuHandle = str(self.menuBar.sender().text())
        self.currentMode = self.MenuModes[MenuHandle]
        s = 'connect' + self.currentMode
        call = getattr(self, s)
        call()

    def disconnectOffStream(self):
        self.TreeFileView.ui.treeWidget.clear()
        self.ImageView.ui.Stream.hide()
        self.TreeFileView.ui.LoadResultsBut.setText("Load Images")
        self.menuBar.actionLoad_Images.setText("Load Images")
        self.menuBar.actionLoad_Images.triggered.connect(self.loadImages)
        self.menuBar.actionLoad_Images.triggered.disconnect(self.loadStream)
        self.TreeFileView.ui.LoadResultsBut.clicked.connect(self.loadImages)
        self.TreeFileView.ui.LoadResultsBut.clicked.connect(self.loadStream)

    def disconnectOffImage(self):
        # Clear the tree (could be saved in cache....)
        self.TreeFileView.ui.treeWidget.clear()

    def disconnectOnPort(self):
        self.ImgModel.ZMQPull.close()
        self.ImgModel.socketTimer.stop()

    def connectOffImage(self):
        self.menuBar.actionFile_Tree.setEnabled(True)
        self.TreeFileView.setVisible(self.TreeFileView.visible)
        self.menuBar.actionHit_Finding.setEnabled(True)
        self.HitFindingView.setVisible(self.HitFindingView.visible)

    def connectOffStream(self):
        print("Switching NPG to Offline Stream Mode")
        # Show the Widget and update the correct bindings
        self.ImageView.ui.Stream.show()
        self.TreeFileView.ui.LoadResultsBut.setText("Load Stream")
        self.menuBar.actionLoad_Images.setText("Load Stream")
        self.menuBar.actionLoad_Images.triggered.disconnect(self.loadImages)
        self.menuBar.actionLoad_Images.triggered.connect(self.loadStream)
        self.TreeFileView.ui.LoadResultsBut.clicked.disconnect(self.loadImages)
        self.TreeFileView.ui.LoadResultsBut.clicked.connect(self.loadStream)
        # Update possible toggled widgets
        # Here ok for tree but not HF - always ok for XP
        self.menuBar.actionFile_Tree.setEnabled(True)
        self.menuBar.actionHit_Finding.setEnabled(False)
        if self.HitFindingView.isVisible():
            self.HitFindingView.hide()

    def connectOnPort(self):
        self.port = 5556
        self.host = 'localhost'
        print("Switching to online mode - listening to port %s from %s" % (str(self.port),self.host))
        if self.TreeFileView.isVisible():
                self.TreeFileView.hide()
        if self.HitFindingView.isVisible():
            self.HitFindingView.hide()
        self.menuBar.actionFile_Tree.setEnabled(False)
        self.menuBar.actionHit_Finding.setEnabled(False)
        self.ImgModel.startZMQPull(self.host, self.port)

    def connectOnEiger(self):
        pass

    def restoreRuns(self):
        d = os.path.realpath(str(self.HitFindingView.ui.ResultsPath.text()))
        dirs = sorted(glob.glob(os.path.join(d,'NPC_run*')))
        self.nRun, self.nRow = self.Table.restoreRows(dirs)


if __name__ == '__main__':
    import sys

    myapp = NPGController(app)
    sys.exit(app.exec_())
